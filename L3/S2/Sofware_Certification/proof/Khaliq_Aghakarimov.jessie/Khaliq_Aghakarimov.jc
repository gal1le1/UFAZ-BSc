# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int8 = -128..127

type int32 = -2147483648..2147483647

tag intP = {
  int32 intM: 32;
}

type intP = [intP]

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

int32 max3(int32 num1, int32 num2, int32 num3)
behavior first_case:
  ensures (_C_5 : true);
behavior first1_case:
  assumes ((num1 > num2) && (num1 > num3));
  ensures (_C_6 : (\result == \at(num1,Old)));
behavior first2_case:
  assumes ((num1 > num2) && (num1 <= num3));
  ensures (_C_7 : (\result == \at(num3,Old)));
behavior second_case:
  ensures (_C_8 : true);
behavior second1_case:
  assumes ((num1 <= num2) && (num2 > num3));
  ensures (_C_9 : (\result == \at(num2,Old)));
behavior second2_case:
  assumes ((num1 <= num2) && (num2 <= num3));
  ensures (_C_10 : (\result == \at(num3,Old)));
behavior default:
  ensures (_C_11 : true);
{  
   (var int32 __retres);
   
   {  (if (num1 > num2) then (if (num1 > num3) then 
                             {  (_C_4 : (__retres = num1));
                                
                                (goto return_label)
                             } else 
                             {  (_C_3 : (__retres = num3));
                                
                                (goto return_label)
                             }) else (if (num2 > num3) then 
                                     {  (_C_2 : (__retres = num2));
                                        
                                        (goto return_label)
                                     } else 
                                     {  (_C_1 : (__retres = num3));
                                        
                                        (goto return_label)
                                     }));
      (return_label : 
      (return __retres))
   }
}

unit doubled(intP[..] t, int32 taille)
  requires (_C_27 : (((_C_29 : (\offset_min(t) <= 0)) &&
                       (_C_30 : (\offset_max(t) >= (taille - 1)))) &&
                      (_C_31 : (taille > 0))));
behavior default:
  ensures (_C_26 : (\forall integer i;
                     (((0 <= i) && (i < \at(taille,Old))) ==>
                       ((\at(t,Old) + i).intM == (2 * i)))));
{  
   (var int32 i);
   
   {  (_C_12 : (i = 0));
      
      loop 
      behavior default:
        invariant (_C_15 : ((_C_16 : (0 <= i)) && (_C_17 : (i <= taille))));
      behavior default:
        invariant (_C_14 : (\forall integer j;
                             (((0 <= j) && (j < i)) ==>
                               ((t + j).intM == (2 * j)))));
      variant (_C_13 : (taille - i));
      while (true)
      {  
         {  (if (i < taille) then () else 
            (goto while_0_break));
            (_C_22 : ((_C_21 : (_C_20 : (t + i)).intM) = (_C_19 : ((_C_18 : 
                                                                   (2 *
                                                                    i)) :> int32))));
            (_C_25 : (i = (_C_24 : ((_C_23 : (i + 1)) :> int32))))
         }
      };
      (while_0_break : ());
      
      (return ())
   }
}

int32 increasing(intP[..] t_0, int32 taille_0)
  requires (_C_54 : (((_C_56 : (\offset_min(t_0) <= 0)) &&
                       (_C_57 : (\offset_max(t_0) >= (taille_0 - 1)))) &&
                      (_C_58 : (taille_0 > 0))));
behavior default:
  ensures (_C_51 : ((_C_52 : ((\forall integer i_0;
                                (((0 <= i_0) &&
                                   (i_0 < (\at(taille_0,Old) - 1))) ==>
                                  ((\at(t_0,Old) + i_0).intM <=
                                    (\at(t_0,Old) + (i_0 + 1)).intM))) ==>
                               (\result == 1))) &&
                     (_C_53 : ((\exists integer i_1;
                                 (((0 <= i_1) &&
                                    (i_1 < (\at(taille_0,Old) - 1))) &&
                                   ((\at(t_0,Old) + i_1).intM >
                                     (\at(t_0,Old) + (i_1 + 1)).intM))) ==>
                                (\result == 0)))));
{  
   (var int32 i_0);
   
   (var int32 __retres_0);
   
   {  
      {  (_C_32 : (i_0 = 0));
         
         loop 
         behavior default:
           invariant (_C_35 : ((_C_36 : (0 <= i_0)) &&
                                (_C_37 : (i_0 <= (taille_0 - 1)))));
         behavior default:
           invariant (_C_34 : (\forall integer j_0;
                                (((0 <= j_0) && (j_0 < i_0)) ==>
                                  ((t_0 + j_0).intM <=
                                    (t_0 + (j_0 + 1)).intM))));
         variant (_C_33 : ((taille_0 - i_0) - 1));
         while (true)
         {  
            {  (if (i_0 < (_C_39 : ((_C_38 : (taille_0 - 1)) :> int32))) then () else 
               (goto while_0_break));
               
               {  (if ((_C_46 : (_C_45 : (t_0 + i_0)).intM) >
                        (_C_44 : (_C_43 : (t_0 +
                                            (_C_42 : ((_C_41 : (i_0 + 1)) :> int32)))).intM)) then 
                  {  (_C_40 : (__retres_0 = 0));
                     
                     (goto return_label)
                  } else ())
               };
               (_C_49 : (i_0 = (_C_48 : ((_C_47 : (i_0 + 1)) :> int32))))
            }
         };
         (while_0_break : ())
      };
      (_C_50 : (__retres_0 = 1));
      (return_label : 
      (return __retres_0))
   }
}

int32 monotonic(intP[..] t_1, int32 taille_1)
  requires (_C_94 : (((_C_96 : (\offset_min(t_1) <= 0)) &&
                       (_C_97 : (\offset_max(t_1) >= (taille_1 - 1)))) &&
                      (_C_98 : (taille_1 > 0))));
behavior default:
  ensures (_C_93 : true);
{  
   (var int32 i_1);
   
   (var int32 i_0_0);
   
   (var int32 __retres_1);
   
   {  
      {  (_C_59 : (i_1 = 1));
         
         loop 
         behavior default:
           invariant (_C_62 : ((_C_63 : (1 <= i_1)) &&
                                (_C_64 : (i_1 <= taille_1))));
         behavior default:
           invariant (_C_61 : (\forall integer j_1;
                                (((1 <= j_1) && (j_1 < i_1)) ==>
                                  ((t_1 + j_1).intM >=
                                    (t_1 + (j_1 - 1)).intM))));
         variant (_C_60 : (taille_1 - i_1));
         while (true)
         {  
            {  (if (i_1 < taille_1) then () else 
               (goto while_0_break));
               
               {  (if ((_C_71 : (_C_70 : (t_1 + i_1)).intM) <
                        (_C_69 : (_C_68 : (t_1 +
                                            (_C_67 : ((_C_66 : (i_1 - 1)) :> int32)))).intM)) then 
                  {  (_C_65 : (__retres_1 = 0));
                     
                     (goto return_label)
                  } else ())
               };
               (_C_74 : (i_1 = (_C_73 : ((_C_72 : (i_1 + 1)) :> int32))))
            }
         };
         (while_0_break : ())
      };
      
      {  (_C_75 : (__retres_1 = 1));
         
         (goto return_label)
      };
      
      {  (_C_76 : (i_0_0 = 1));
         
         loop 
         behavior default:
           invariant (_C_79 : ((_C_80 : (1 <= i_0_0)) &&
                                (_C_81 : (i_0_0 <= taille_1))));
         behavior default:
           invariant (_C_78 : (\forall integer j_2;
                                (((1 <= j_2) && (j_2 < i_0_0)) ==>
                                  ((t_1 + j_2).intM <=
                                    (t_1 + (j_2 - 1)).intM))));
         variant (_C_77 : (taille_1 - i_0_0));
         while (true)
         {  
            {  (if (i_0_0 < taille_1) then () else 
               (goto while_0_break_0));
               
               {  (if ((_C_88 : (_C_87 : (t_1 + i_0_0)).intM) >
                        (_C_86 : (_C_85 : (t_1 +
                                            (_C_84 : ((_C_83 : (i_0_0 - 1)) :> int32)))).intM)) then 
                  {  (_C_82 : (__retres_1 = 0));
                     
                     (goto return_label)
                  } else ())
               };
               (_C_91 : (i_0_0 = (_C_90 : ((_C_89 : (i_0_0 + 1)) :> int32))))
            }
         };
         (while_0_break_0 : ())
      };
      (_C_92 : (__retres_1 = 1));
      (return_label : 
      (return __retres_1))
   }
}

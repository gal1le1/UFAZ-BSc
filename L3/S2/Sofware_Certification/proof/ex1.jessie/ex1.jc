# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int8 = -128..127

type int32 = -2147483648..2147483647

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

int32 max3(int32 num1, int32 num2, int32 num3)
behavior first_case:
  ensures (_C_5 : true);
behavior first1_case:
  assumes ((num1 > num2) && (num1 > num3));
  ensures (_C_6 : (\result == \at(num1,Old)));
behavior first2_case:
  assumes ((num1 > num2) && (num1 <= num3));
  ensures (_C_7 : (\result == \at(num3,Old)));
behavior second_case:
  ensures (_C_8 : true);
behavior second1_case:
  assumes ((num1 <= num2) && (num2 > num3));
  ensures (_C_9 : (\result == \at(num2,Old)));
behavior second2_case:
  assumes ((num1 <= num2) && (num2 <= num3));
  ensures (_C_10 : (\result == \at(num3,Old)));
behavior default:
  ensures (_C_11 : true);
{  
   (var int32 __retres);
   
   {  (if (num1 > num2) then (if (num1 > num3) then 
                             {  (_C_4 : (__retres = num1));
                                
                                (goto return_label)
                             } else 
                             {  (_C_3 : (__retres = num3));
                                
                                (goto return_label)
                             }) else (if (num2 > num3) then 
                                     {  (_C_2 : (__retres = num2));
                                        
                                        (goto return_label)
                                     } else 
                                     {  (_C_1 : (__retres = num3));
                                        
                                        (goto return_label)
                                     }));
      (return_label : 
      (return __retres))
   }
}

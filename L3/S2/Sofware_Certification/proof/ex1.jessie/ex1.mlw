theory Jessie_model

use import int.Int

use bool.Bool

use import jessie_why3theories.Jessie_memory_model

type charP

type int32

type int8

type padding

type voidP

function charP_tag  : (tag_id charP)

axiom charP_int "charP_int": ((int_of_tag charP_tag) = (1))

function charP_of_pointer_address (pointer ()) : (pointer charP)

axiom charP_of_pointer_address_of_pointer_addr "charP_of_pointer_address_of_pointer_addr":
 (forall p:(pointer charP).
  (p = (charP_of_pointer_address (pointer_address p))))

axiom charP_parenttag_bottom "charP_parenttag_bottom":
 (parenttag charP_tag bottom_tag)

axiom charP_tags "charP_tags":
 (forall x:(pointer charP).
  (forall charP_tag_table:(tag_table charP).
   (instanceof charP_tag_table x charP_tag)))

function integer_of_int32 int32 : int

predicate eq_int32(x:int32) (y:int32) =
 ((integer_of_int32 x) = (integer_of_int32 y))

function integer_of_int8 int8 : int

predicate eq_int8(x:int8) (y:int8) =
 ((integer_of_int8 x) = (integer_of_int8 y))

function int32_of_integer int : int32

axiom int32_coerce "int32_coerce":
 (forall x:int.
  (((Int.(<=) (-2147483648) x) /\ (Int.(<=) x (2147483647))) ->
   ((integer_of_int32 (int32_of_integer x)) = x)))

axiom int32_extensionality "int32_extensionality":
 (forall x:int32.
  (forall y:int32[((integer_of_int32 x) = (integer_of_int32 y))].
   (((integer_of_int32 x) = (integer_of_int32 y)) -> (x = y))))

axiom int32_range "int32_range":
 (forall x:int32.
  ((Int.(<=) (-2147483648) (integer_of_int32 x))
  /\ (Int.(<=) (integer_of_int32 x) (2147483647))))

function int8_of_integer int : int8

axiom int8_coerce "int8_coerce":
 (forall x:int.
  (((Int.(<=) (-128) x) /\ (Int.(<=) x (127))) ->
   ((integer_of_int8 (int8_of_integer x)) = x)))

axiom int8_extensionality "int8_extensionality":
 (forall x:int8.
  (forall y:int8[((integer_of_int8 x) = (integer_of_int8 y))].
   (((integer_of_int8 x) = (integer_of_int8 y)) -> (x = y))))

axiom int8_range "int8_range":
 (forall x:int8.
  ((Int.(<=) (-128) (integer_of_int8 x))
  /\ (Int.(<=) (integer_of_int8 x) (127))))

predicate left_valid_struct_charP(p:(pointer charP)) (a:int) (charP_alloc_table:(alloc_table charP)) =
 ((offset_min charP_alloc_table p) <= a)

predicate left_valid_struct_voidP(p:(pointer voidP)) (a:int) (voidP_alloc_table:(alloc_table voidP)) =
 ((offset_min voidP_alloc_table p) <= a)

axiom pointer_addr_of_charP_of_pointer_address "pointer_addr_of_charP_of_pointer_address":
 (forall p:(pointer ()).
  (p = (pointer_address (charP_of_pointer_address p))))

function voidP_of_pointer_address (pointer ()) : (pointer voidP)

axiom pointer_addr_of_voidP_of_pointer_address "pointer_addr_of_voidP_of_pointer_address":
 (forall p:(pointer ()).
  (p = (pointer_address (voidP_of_pointer_address p))))

predicate right_valid_struct_charP(p:(pointer charP)) (b:int) (charP_alloc_table:(alloc_table charP)) =
 ((offset_max charP_alloc_table p) >= b)

predicate right_valid_struct_voidP(p:(pointer voidP)) (b:int) (voidP_alloc_table:(alloc_table voidP)) =
 ((offset_max voidP_alloc_table p) >= b)

predicate strict_valid_root_charP(p:(pointer charP)) (a:int) (b:int) (charP_alloc_table:(alloc_table charP)) =
 (((offset_min charP_alloc_table p) = a)
 /\ ((offset_max charP_alloc_table p) = b))

predicate strict_valid_root_voidP(p:(pointer voidP)) (a:int) (b:int) (voidP_alloc_table:(alloc_table voidP)) =
 (((offset_min voidP_alloc_table p) = a)
 /\ ((offset_max voidP_alloc_table p) = b))

predicate strict_valid_struct_charP(p:(pointer charP)) (a:int) (b:int) (charP_alloc_table:(alloc_table charP)) =
 (((offset_min charP_alloc_table p) = a)
 /\ ((offset_max charP_alloc_table p) = b))

predicate strict_valid_struct_voidP(p:(pointer voidP)) (a:int) (b:int) (voidP_alloc_table:(alloc_table voidP)) =
 (((offset_min voidP_alloc_table p) = a)
 /\ ((offset_max voidP_alloc_table p) = b))

predicate valid_root_charP(p:(pointer charP)) (a:int) (b:int) (charP_alloc_table:(alloc_table charP)) =
 (((offset_min charP_alloc_table p) <= a)
 /\ ((offset_max charP_alloc_table p) >= b))

predicate valid_root_voidP(p:(pointer voidP)) (a:int) (b:int) (voidP_alloc_table:(alloc_table voidP)) =
 (((offset_min voidP_alloc_table p) <= a)
 /\ ((offset_max voidP_alloc_table p) >= b))

predicate valid_struct_charP(p:(pointer charP)) (a:int) (b:int) (charP_alloc_table:(alloc_table charP)) =
 (((offset_min charP_alloc_table p) <= a)
 /\ ((offset_max charP_alloc_table p) >= b))

predicate valid_struct_voidP(p:(pointer voidP)) (a:int) (b:int) (voidP_alloc_table:(alloc_table voidP)) =
 (((offset_min voidP_alloc_table p) <= a)
 /\ ((offset_max voidP_alloc_table p) >= b))

function voidP_tag  : (tag_id voidP)

axiom voidP_int "voidP_int": ((int_of_tag voidP_tag) = (1))

axiom voidP_of_pointer_address_of_pointer_addr "voidP_of_pointer_address_of_pointer_addr":
 (forall p:(pointer voidP).
  (p = (voidP_of_pointer_address (pointer_address p))))

axiom voidP_parenttag_bottom "voidP_parenttag_bottom":
 (parenttag voidP_tag bottom_tag)

axiom voidP_tags "voidP_tags":
 (forall x:(pointer voidP).
  (forall voidP_tag_table:(tag_table voidP).
   (instanceof voidP_tag_table x voidP_tag)))

end

module Jessie_program

use import int.Int

use bool.Bool

use import jessie_why3theories.Jessie_memory_model

use import Jessie_model

use import ref.Ref

use import jessie_why3.JessieDivision

use import jessie_why3.Jessie_memory_model_parameters

exception Loop_continue_exc ()

exception Loop_exit_exc ()

exception Return_label_exc ()

val charP_alloc_table : ref (alloc_table charP)

val charP_tag_table : ref (tag_table charP)

val alloc_struct_charP
 (n:int)
  (charP_alloc_table:ref (alloc_table charP))
   (charP_tag_table:ref (tag_table charP)) : (pointer charP)
    requires { true } writes { charP_alloc_table, charP_tag_table }
     ensures { ((strict_valid_struct_charP result (0) (Int.(-) n (1))
                !charP_alloc_table)
               /\ ((alloc_extends (old !charP_alloc_table)
                   !charP_alloc_table)
                  /\ ((alloc_fresh (old !charP_alloc_table) result n)
                     /\ (instanceof !charP_tag_table result charP_tag)))) }

val alloc_struct_charP_requires
 (n:int)
  (charP_alloc_table:ref (alloc_table charP))
   (charP_tag_table:ref (tag_table charP)) : (pointer charP)
    requires { (Int.(>=) n (0)) } writes { charP_alloc_table,
    charP_tag_table }
     ensures { ((strict_valid_struct_charP result (0) (Int.(-) n (1))
                !charP_alloc_table)
               /\ ((alloc_extends (old !charP_alloc_table)
                   !charP_alloc_table)
                  /\ ((alloc_fresh (old !charP_alloc_table) result n)
                     /\ (instanceof !charP_tag_table result charP_tag)))) }

val voidP_alloc_table : ref (alloc_table voidP)

val voidP_tag_table : ref (tag_table voidP)

val alloc_struct_voidP
 (n:int)
  (voidP_alloc_table:ref (alloc_table voidP))
   (voidP_tag_table:ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures { ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
                !voidP_alloc_table)
               /\ ((alloc_extends (old !voidP_alloc_table)
                   !voidP_alloc_table)
                  /\ ((alloc_fresh (old !voidP_alloc_table) result n)
                     /\ (instanceof !voidP_tag_table result voidP_tag)))) }

val alloc_struct_voidP_requires
 (n:int)
  (voidP_alloc_table:ref (alloc_table voidP))
   (voidP_tag_table:ref (tag_table voidP)) : (pointer voidP)
    requires { (Int.(>=) n (0)) } writes { voidP_alloc_table,
    voidP_tag_table }
     ensures { ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
                !voidP_alloc_table)
               /\ ((alloc_extends (old !voidP_alloc_table)
                   !voidP_alloc_table)
                  /\ ((alloc_fresh (old !voidP_alloc_table) result n)
                     /\ (instanceof !voidP_tag_table result voidP_tag)))) }

val any_int32 (_anonymous:()) : int32 requires { true }  ensures { true }

val any_int8 (_anonymous:()) : int8 requires { true }  ensures { true }

val int32_of_integer_
 (x:int) : int32
  requires { ((Int.(<=) (-2147483648) x) /\ (Int.(<=) x (2147483647))) }
   ensures { ((integer_of_int32 result) = x) }

val int8_of_integer_
 (x:int) : int8
  requires { ((Int.(<=) (-128) x) /\ (Int.(<=) x (127))) }
   ensures { ((integer_of_int8 result) = x) }

val max3
 (num1:int32)
  (num2:int32)
   (num3:int32) : int32
    requires { true }
     ensures { ((((Int.(<=) (integer_of_int32 num1) (integer_of_int32 num2))
                 /\ (Int.(<=) (integer_of_int32 num2)
                    (integer_of_int32 num3))) ->
                 (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 22 11 26#
                 ((integer_of_int32 result) = (integer_of_int32 num3))))
               /\ ((((Int.(<=) (integer_of_int32 num1)
                     (integer_of_int32 num2))
                    /\ (Int.(>) (integer_of_int32 num2)
                       (integer_of_int32 num3))) ->
                    (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 18 11 26#
                    ((integer_of_int32 result) = (integer_of_int32 num2))))
                  /\ ((((Int.(>) (integer_of_int32 num1)
                        (integer_of_int32 num2))
                       /\ (Int.(<=) (integer_of_int32 num1)
                          (integer_of_int32 num3))) ->
                       (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 12 11 26#
                       ((integer_of_int32 result) = (integer_of_int32 num3))))
                     /\ (((Int.(>) (integer_of_int32 num1)
                          (integer_of_int32 num2))
                         /\ (Int.(>) (integer_of_int32 num1)
                            (integer_of_int32 num3))) ->
                         (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 6 11 26#
                         ((integer_of_int32 result) = (integer_of_int32 num1))))))) }

val max3_requires
 (num1:int32)
  (num2:int32)
   (num3:int32) : int32
    requires { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
               true) }
     ensures { ((((Int.(<=) (integer_of_int32 num1) (integer_of_int32 num2))
                 /\ (Int.(<=) (integer_of_int32 num2)
                    (integer_of_int32 num3))) ->
                 (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 22 11 26#
                 ((integer_of_int32 result) = (integer_of_int32 num3))))
               /\ ((((Int.(<=) (integer_of_int32 num1)
                     (integer_of_int32 num2))
                    /\ (Int.(>) (integer_of_int32 num2)
                       (integer_of_int32 num3))) ->
                    (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 18 11 26#
                    ((integer_of_int32 result) = (integer_of_int32 num2))))
                  /\ ((((Int.(>) (integer_of_int32 num1)
                        (integer_of_int32 num2))
                       /\ (Int.(<=) (integer_of_int32 num1)
                          (integer_of_int32 num3))) ->
                       (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 12 11 26#
                       ((integer_of_int32 result) = (integer_of_int32 num3))))
                     /\ (((Int.(>) (integer_of_int32 num1)
                          (integer_of_int32 num2))
                         /\ (Int.(>) (integer_of_int32 num1)
                            (integer_of_int32 num3))) ->
                         (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 6 11 26#
                         ((integer_of_int32 result) = (integer_of_int32 num1))))))) }

val safe_int32_of_integer_
 (x:int) : int32
  requires { true }  ensures { ((integer_of_int32 result) = x) }

val safe_int8_of_integer_
 (x:int) : int8 requires { true }  ensures { ((integer_of_int8 result) = x) }

let max3_ensures_default "W:diverges:N" "expl:Function max3, default behavior"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
             true)  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
            true) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_12 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_14 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_16 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_18 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_ensures_first1_case "W:diverges:N" "expl:Function max3, Behavior `first1_case'"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { ((Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
             /\ (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3)))  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 6 11 26#
            ((integer_of_int32 result) = (integer_of_int32 num1))) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_30 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_32 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_34 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_36 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_ensures_first2_case "W:diverges:N" "expl:Function max3, Behavior `first2_case'"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { ((Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
             /\ (Int.(<=) (integer_of_int32 num1) (integer_of_int32 num3)))  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 12 11 26#
            ((integer_of_int32 result) = (integer_of_int32 num3))) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_39 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_41 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_43 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_45 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_ensures_first_case "W:diverges:N" "expl:Function max3, Behavior `first_case'"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
             true)  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
            true) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_21 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_23 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_25 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_27 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_ensures_second1_case "W:diverges:N" "expl:Function max3, Behavior `second1_case'"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { ((Int.(<=) (integer_of_int32 num1) (integer_of_int32 num2))
             /\ (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3)))  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 18 11 26#
            ((integer_of_int32 result) = (integer_of_int32 num2))) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_57 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_59 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_61 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_63 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_ensures_second2_case "W:diverges:N" "expl:Function max3, Behavior `second2_case'"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { ((Int.(<=) (integer_of_int32 num1) (integer_of_int32 num2))
             /\ (Int.(<=) (integer_of_int32 num2) (integer_of_int32 num3)))  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 22 11 26#
            ((integer_of_int32 result) = (integer_of_int32 num3))) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_66 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_68 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_70 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_72 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_ensures_second_case "W:diverges:N" "expl:Function max3, Behavior `second_case'"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
             true)  }
  ensures { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
            true) } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_48 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_50 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_52 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_54 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

let max3_safety "expl:Function max3, Safety"
 #"/home/xaliq/CS/L3/S2/Certification/proof/ex1.c" 25 4 8#=
 fun (num1 : int32) (num2 : int32) (num3 : int32) ->
  requires { (#"/home/xaliq/CS/L3/S2/Certification/proof/ex1.jessie/" 0 0 0#
             true)  } ensures { true } 
  ('Init: 
  (let return = ref (any_int32 ()) in
  try
   begin
     (let __retres = ref (any_int32 ()) in
     try
      begin
        (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num2))
        then
         (if (Int.(>) (integer_of_int32 num1) (integer_of_int32 num3))
         then
          begin
            (let _jessie_3 = (__retres := num1) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_5 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)
        else
         (if (Int.(>) (integer_of_int32 num2) (integer_of_int32 num3))
         then
          begin
            (let _jessie_7 = (__retres := num2) in ());
           (raise (Return_label_exc ())) end
         else
          begin
            (let _jessie_9 = (__retres := num3) in ());
           (raise (Return_label_exc ())) end)); (raise (Return_label_exc ()))
      end with Return_label_exc _jessie_1 ->
      ('Return_label:  begin   (return := !__retres); (raise Return) end) end);
    absurd  end with Return -> !return end)) 

end



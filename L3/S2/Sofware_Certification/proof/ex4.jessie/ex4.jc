# IntModel = bounded
# InvariantPolicy = Arguments
# SeparationPolicy = Regions
# AnnotationPolicy = None
# AbstractDomain = Pol

axiomatic Padding {

  logic type padding
  
}

type int8 = -128..127

type int32 = -2147483648..2147483647

tag intP = {
  int32 intM: 32;
}

type intP = [intP]

tag charP = {
  int8 charM: 8;
}

type charP = [charP]

tag voidP = {
}

type voidP = [voidP]

int32 monotonic(intP[..] t, int32 taille)
  requires (_C_36 : (((_C_38 : (\offset_min(t) <= 0)) &&
                       (_C_39 : (\offset_max(t) >= (taille - 1)))) &&
                      (_C_40 : (taille > 0))));
behavior default:
  ensures (_C_35 : true);
{  
   (var int32 i);
   
   (var int32 i_0);
   
   (var int32 __retres);
   
   {  
      {  (_C_1 : (i = 1));
         
         loop 
         behavior default:
           invariant (_C_4 : ((_C_5 : (1 <= i)) && (_C_6 : (i <= taille))));
         behavior default:
           invariant (_C_3 : (\forall integer j;
                               (((1 <= j) && (j < i)) ==>
                                 ((t + j).intM >= (t + (j - 1)).intM))));
         variant (_C_2 : (taille - i));
         while (true)
         {  
            {  (if (i < taille) then () else 
               (goto while_0_break));
               
               {  (if ((_C_13 : (_C_12 : (t + i)).intM) <
                        (_C_11 : (_C_10 : (t +
                                            (_C_9 : ((_C_8 : (i - 1)) :> int32)))).intM)) then 
                  {  (_C_7 : (__retres = 0));
                     
                     (goto return_label)
                  } else ())
               };
               (_C_16 : (i = (_C_15 : ((_C_14 : (i + 1)) :> int32))))
            }
         };
         (while_0_break : ())
      };
      
      {  (_C_17 : (__retres = 1));
         
         (goto return_label)
      };
      
      {  (_C_18 : (i_0 = 1));
         
         loop 
         behavior default:
           invariant (_C_21 : ((_C_22 : (1 <= i_0)) &&
                                (_C_23 : (i_0 <= taille))));
         behavior default:
           invariant (_C_20 : (\forall integer j_0;
                                (((1 <= j_0) && (j_0 < i_0)) ==>
                                  ((t + j_0).intM <= (t + (j_0 - 1)).intM))));
         variant (_C_19 : (taille - i_0));
         while (true)
         {  
            {  (if (i_0 < taille) then () else 
               (goto while_0_break_0));
               
               {  (if ((_C_30 : (_C_29 : (t + i_0)).intM) >
                        (_C_28 : (_C_27 : (t +
                                            (_C_26 : ((_C_25 : (i_0 - 1)) :> int32)))).intM)) then 
                  {  (_C_24 : (__retres = 0));
                     
                     (goto return_label)
                  } else ())
               };
               (_C_33 : (i_0 = (_C_32 : ((_C_31 : (i_0 + 1)) :> int32))))
            }
         };
         (while_0_break_0 : ())
      };
      (_C_34 : (__retres = 1));
      (return_label : 
      (return __retres))
   }
}
